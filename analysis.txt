=== PC Calculator - Design Analysis and Decision Documentation ===
Author: Student + Claude AI Assistant
Date: 2025-11-13
Purpose: Document design decisions, brainstorming, and rationale for implementation choices

================================================================================
1. ARCHITECTURE OVERVIEW
================================================================================

1.1 High-Level Design Decision: Modular Architecture
-----------------------------------------------------
DECISION: Split project into 8 focused modules + main
RATIONALE:
- Single Responsibility Principle: Each module has one clear purpose
- Maintainability: Easy to locate and fix bugs
- Testability: Each module can be tested independently
- Scalability: Easy to extend functionality without affecting other parts
- Code review: Smaller files are easier to review

ALTERNATIVE CONSIDERED: Monolithic design (reference implementation approach)
WHY REJECTED:
- Harder to maintain
- Difficult to test individual components
- Violation of clean code principles

MODULE BREAKDOWN:
- core/bignum: Number representation and basic utilities
- core/bignum_ops: Arithmetic operations (+, -, *, /, %)
- core/bignum_math: Advanced math (^, !)
- conversion/converter: Input parsing (bin/hex/dec → BigNum)
- conversion/formatter: Output formatting (BigNum → bin/hex/dec)
- expression/parser: Infix to postfix conversion
- expression/evaluator: Postfix expression evaluation
- app/calculator: Application logic and command handling
- app/utils: String manipulation and I/O utilities
- main: Entry point and argument handling

1.2 Folder Structure
--------------------
DECISION: Separate src/ and include/ with mirrored subdirectories
RATIONALE:
- Industry standard C project layout
- Clear separation of interface (.h) and implementation (.c)
- Makes it obvious what is public API
- Professional appearance

STRUCTURE:
src/
  core/          - Core functionality
  conversion/    - Format conversion
  expression/    - Expression handling
  app/           - Application layer
include/
  (mirrors src structure)


================================================================================
2. NUMBER REPRESENTATION
================================================================================

2.1 Internal Representation: Decimal Strings
---------------------------------------------
DECISION: Store numbers as decimal digit strings with separate sign flag

typedef struct {
    bool isNegative;
    char* digits;     /* "12345" for value 12345 */
} BigNum;

RATIONALE:
- Simplicity: Easy to understand and debug
- Direct output: Decimal mode requires no conversion
- Clear semantics: Sign and magnitude separated
- No two's complement complexity internally
- Standard approach in many bignum libraries

ALTERNATIVE CONSIDERED: Pseudo-hexadecimal (like reference implementation)
WHY REJECTED:
- More complex to implement
- Requires conversion for decimal output
- Not significantly faster for our use case
- Harder to debug

ALTERNATIVE CONSIDERED: Binary representation
WHY REJECTED:
- More memory intensive (bits vs digits)
- Complex conversion to/from decimal
- No performance benefit for unlimited precision

ALTERNATIVE CONSIDERED: Array of integers (base 10^9 or similar)
WHY REJECTED:
- More complex overflow handling
- Requires careful base management
- String approach is simpler for this project

2.2 Sign Handling
-----------------
DECISION: Zero is never negative (canonical form)
RATIONALE:
- Prevents -0 vs +0 confusion
- Simplifies comparison operations
- Standard mathematical convention

IMPLEMENTATION:
- After any operation, check if result is "0"
- If zero, force isNegative = false
- Consistent across all operations

2.3 Leading Zero Handling
--------------------------
DECISION: Remove leading zeros immediately after all operations
RATIONALE:
- Canonical representation: "123" not "00123"
- Simpler comparisons: Can use strcmp on equal-length numbers
- Minimal output requirement from specification
- Prevents memory waste

IMPLEMENTATION:
- Helper function removeLeadingZeros() called after operations
- Always leaves at least one digit ("0")


================================================================================
3. ARITHMETIC ALGORITHMS
================================================================================

3.1 Addition Algorithm
----------------------
DECISION: Column addition with carry (elementary school method)
RATIONALE:
- Simple and well-understood
- O(n) time complexity (optimal)
- Easy to implement correctly
- No faster algorithm exists for addition

ALGORITHM:
1. Add digits from right to left
2. Propagate carry
3. Handle different lengths
4. Sign handling:
   - Same signs: add magnitudes, keep sign
   - Different signs: subtract smaller from larger, take larger's sign

3.2 Subtraction Algorithm
--------------------------
DECISION: Implement as a - b = a + (-b) using negation and addition
RATIONALE:
- Code reuse: Leverages already-implemented add()
- Fewer bugs: One less algorithm to get right
- Simpler than column subtraction with borrow
- Standard approach in many libraries

ALTERNATIVE CONSIDERED: Direct column subtraction
WHY REJECTED:
- More complex to handle borrows
- More edge cases to test
- No performance benefit

3.3 Multiplication Algorithm
-----------------------------
DECISION: Long multiplication (elementary school method)
RATIONALE:
- Simple O(n²) algorithm sufficient for this project
- Easy to implement correctly
- Clear and understandable

ALGORITHM:
1. Allocate result array (size = lenA + lenB)
2. Multiply each digit of A by each digit of B
3. Place results in correct positions
4. Handle carries
5. Convert to string

ALTERNATIVE CONSIDERED: Karatsuba algorithm
WHY REJECTED:
- More complex: O(n^1.585) but higher constant
- Only faster for very large numbers (>1000 digits)
- Overkill for this project
- Harder to implement correctly

ALTERNATIVE CONSIDERED: FFT-based multiplication
WHY REJECTED:
- Extreme overkill
- Only useful for numbers with 10,000+ digits
- Very complex to implement

3.4 Division Algorithm
----------------------
DECISION: Long division (digit-by-digit)
RATIONALE:
- Matches elementary school algorithm
- Works for any size numbers
- O(n²) complexity acceptable for project scope

ALGORITHM:
1. Process dividend digit by digit (left to right)
2. For each digit:
   a. Bring down next digit
   b. Count how many times divisor fits
   c. Append count to quotient
   d. Update remainder
3. Handle signs separately

ALTERNATIVE CONSIDERED: Binary search division
WHY REJECTED:
- More complex
- Not significantly faster for most cases
- Requires many multiplications

ALTERNATIVE CONSIDERED: Newton-Raphson division
WHY REJECTED:
- Very complex
- Requires floating point approximation
- Overkill for integer division

3.5 Modulo Operation
--------------------
DECISION: Use formula a % m = a - m * (a / b)
RATIONALE:
- Leverages already-implemented division and multiplication
- Mathematically correct
- Matches C language semantics (round toward zero)

SPECIFICATION REQUIREMENT:
"a % m = a - m * ⌊a/m⌋ where ⌊a/m⌋ is rounded toward zero"

IMPLEMENTATION:
1. Compute quotient = divide(a, b)
2. Compute product = multiply(b, quotient)
3. Compute remainder = subtract(a, product)

3.6 Power Algorithm
-------------------
DECISION: Binary exponentiation (exponentiation by squaring)
RATIONALE:
- O(log n) complexity vs O(n) for naive approach
- Significant speedup for large exponents
- Standard algorithm in all professional libraries

ALGORITHM:
result = 1
while (exponent > 0):
    if (exponent is odd):
        result *= base
    base *= base  (square)
    exponent /= 2

EXAMPLE: 2^10
- Instead of 9 multiplications (2*2*2*2*2*2*2*2*2*2)
- Do 4: square(2)=4, square(4)=16, square(16)=256, square(256)=65536
- Result: 1024 (through selective multiplications)

ALTERNATIVE CONSIDERED: Naive repeated multiplication
WHY REJECTED:
- O(n) complexity too slow for large exponents
- Example: 2^1000 would need 999 multiplications
- Binary method needs only ~10 multiplications

3.7 Factorial Algorithm
------------------------
DECISION: Iterative multiplication (2 * 3 * 4 * ... * n)
RATIONALE:
- Simple and straightforward
- O(n) multiplications (optimal)
- Easy memory management

ALGORITHM:
result = 1
for i = 2 to n:
    result *= i

ALTERNATIVE CONSIDERED: Recursive approach
WHY REJECTED:
- Risk of stack overflow for large n
- No performance benefit
- Harder to manage memory

ALTERNATIVE CONSIDERED: Tree-based (like reference)
WHY REJECTED:
- More complex
- Only faster for VERY large factorials (n > 10000)
- Added complexity not justified for this project
- Can be optimized later if needed


================================================================================
4. TWO'S COMPLEMENT HANDLING
================================================================================

4.1 Design Challenge: Input Interpretation
-------------------------------------------
CRITICAL SPECIFICATION REQUIREMENT:
"For bin/hex encoding, use two's complement EXCLUSIVELY"

EXAMPLES FROM SPEC:
3 = 0b000...00011 = 0b011 ≠ 0b11 = 0b111...11111 = -1
11 = 0b0001011 = 0x0000b = 0x0b ≠ 0xb = 0xffffb = 0b1011 = -5

KEY INSIGHT: Leading bit/digit determines sign!

BINARY:
- Leading 0: Positive number
- Leading 1: Negative number (two's complement)

HEXADECIMAL:
- Leading 0-7: Positive number
- Leading 8-F: Negative number (two's complement)

4.2 Conversion Strategy: Binary → Decimal
------------------------------------------
ALGORITHM FOR POSITIVE (leading bit = 0):
1. Standard binary-to-decimal conversion
2. Result is positive BigNum

ALGORITHM FOR NEGATIVE (leading bit = 1):
1. Recognize it's negative from leading bit
2. Invert all bits: 0→1, 1→0
3. Add 1 (two's complement formula)
4. Convert result to decimal
5. Make BigNum negative

EXAMPLE: 0b11 = -1
1. Leading bit is 1, so negative
2. Invert: 11 → 00
3. Add 1: 00 + 1 = 01
4. Convert: 01₂ = 1₁₀
5. Result: -1

4.3 Conversion Strategy: Hexadecimal → Decimal
-----------------------------------------------
ALGORITHM FOR POSITIVE (leading digit 0-7):
1. Standard hex-to-decimal conversion
2. Result is positive BigNum

ALGORITHM FOR NEGATIVE (leading digit 8-F):
1. Recognize it's negative from leading digit
2. Convert hex to binary (4 bits per hex digit)
3. Follow binary negative conversion process
4. Result is negative BigNum

EXAMPLE: 0xf = -1
1. Leading digit is F (≥8), so negative
2. F → 1111 in binary
3. This is 0b1111
4. Follow binary negative process
5. Result: -1

4.4 Conversion Strategy: Decimal → Binary/Hex Output
-----------------------------------------------------
ALGORITHM FOR POSITIVE NUMBERS:
1. Standard decimal-to-binary/hex conversion
2. Ensure leading bit/digit is 0 (for positive indication)
3. If not, prepend a 0

ALGORITHM FOR NEGATIVE NUMBERS:
1. Take absolute value
2. Convert to binary/hex
3. Invert all bits/apply two's complement
4. Ensure leading bit/digit is 1 (for negative indication)

MINIMAL OUTPUT REQUIREMENT:
- Don't output unnecessary leading zeros
- For positive: 0b011 (not 0b0000011)
- For negative: 0b11 (not 0b11111111)
- Smallest representation that preserves sign

4.5 Why Separate Converter and Formatter
-----------------------------------------
DECISION: Split input (converter) and output (formatter)
RATIONALE:
- Input parsing is complex (detect format, validate, convert)
- Output formatting is different (must minimize digits)
- Separation of concerns
- Easier to test independently
- Different error handling requirements

CONVERTER: String → BigNum
- Validate input format
- Detect sign from leading bit/digit
- Convert using two's complement if needed
- Return BigNum in our internal format (decimal string)

FORMATTER: BigNum → String
- Convert from internal format
- Apply two's complement if negative
- Minimize representation
- Add proper prefix (0b, 0x)


================================================================================
5. EXPRESSION PARSING
================================================================================

5.1 Algorithm Choice: Shunting Yard
------------------------------------
DECISION: Use Dijkstra's Shunting Yard algorithm for infix→postfix conversion
RATIONALE:
- Industry standard for expression parsing
- Handles operator precedence automatically
- Handles parentheses naturally
- O(n) time complexity
- Well-documented and tested

ALGORITHM OVERVIEW:
1. Read tokens left to right
2. Numbers: output directly
3. Operators: push to stack based on precedence
4. Left parenthesis: push to stack
5. Right parenthesis: pop until matching left paren
6. At end: pop all remaining operators

ALTERNATIVE CONSIDERED: Recursive descent parser
WHY REJECTED:
- More complex to implement
- Harder to handle precedence
- No advantage for simple arithmetic

ALTERNATIVE CONSIDERED: Direct evaluation (no postfix)
WHY REJECTED:
- Much more complex
- Error-prone
- Shunting Yard is cleaner

5.2 Special Operator Handling
------------------------------
CHALLENGE 1: Right-associative power operator
SPECIFICATION: ^ is right-associative
MEANING: 2^3^2 = 2^(3^2) = 2^9 = 512  (not (2^3)^2 = 8^2 = 64)

SOLUTION IN SHUNTING YARD:
- When seeing ^, pop operators with precedence > (not ≥)
- This makes it right-associative

CHALLENGE 2: Postfix factorial
SPECIFICATION: ! is postfix unary operator
MEANING: 5! not !5

SOLUTION IN SHUNTING YARD:
- Treat ! as highest precedence
- When parsing, attach to preceding number
- Process immediately in postfix evaluation

5.3 Operator Precedence Table (from specification)
---------------------------------------------------
Priority 5 (highest): ! (factorial) - postfix unary
Priority 4: ^ (power) - binary, RIGHT-associative
Priority 3: - (unary minus) - prefix unary, RIGHT-associative
Priority 3: * / (multiply, divide) - binary, left-associative
Priority 2: % (modulo) - binary, left-associative
Priority 1 (lowest): + - (plus, minus) - binary, left-associative
Priority 0: ( ) parentheses

IMPLEMENTATION:
const int precedence[] = {
    '!': 5,
    '^': 4,
    '_': 3,  /* unary minus (internal representation) */
    '*': 3,
    '/': 3,
    '%': 2,
    '+': 1,
    '-': 1
};

5.4 Unary Minus Handling
-------------------------
CHALLENGE: Distinguish unary minus from binary minus
EXAMPLES:
- Binary: 5 - 3
- Unary: -5 or -(5+3)

SOLUTION:
1. During tokenization, detect context
2. Replace unary minus with special token '_'
3. Parser treats '_' as separate operator with precedence 3
4. Evaluator applies negation

DETECTION RULES:
Unary minus appears:
- At start of expression: "-5"
- After operator: "5 * -3"
- After left parenthesis: "(-5 + 3)"


================================================================================
6. MEMORY MANAGEMENT STRATEGY
================================================================================

6.1 Philosophy: Immediate Cleanup
----------------------------------
PRINCIPLE: Free memory as soon as it's no longer needed
RATIONALE:
- Prevents accumulation of temporary objects
- Avoids memory leaks (P102 error in chybovnik)
- Makes ownership clear

PATTERN:
BigNum* temp = operation(a, b);
BigNum* result = otherOperation(temp, c);
destroyBigNum(temp);  /* Free immediately */
return result;

6.2 Object Ownership Model
---------------------------
RULE: Functions that create BigNum objects return ownership to caller
RESPONSIBILITY: Caller must free returned objects

EXAMPLE:
BigNum* a = createBigNum("5");
BigNum* b = createBigNum("3");
BigNum* result = add(a, b);  /* Creates new object */
/* Caller owns result and must free it */
destroyBigNum(result);
destroyBigNum(a);
destroyBigNum(b);

6.3 Common Memory Patterns
---------------------------
PATTERN 1: Chaining operations
BigNum* a = createBigNum("5");
BigNum* b = createBigNum("3");
BigNum* temp = add(a, b);
BigNum* result = multiply(temp, a);
destroyBigNum(temp);  /* Don't forget! */

PATTERN 2: In-place update
BigNum* accumulator = createBigNum("1");
for (...) {
    BigNum* temp = multiply(accumulator, current);
    destroyBigNum(accumulator);
    accumulator = temp;  /* Transfer ownership */
}

PATTERN 3: Error handling
BigNum* result = operation(a, b);
if (result == NULL) {
    /* Clean up and return error */
    destroyBigNum(a);
    destroyBigNum(b);
    return NULL;
}

6.4 Avoiding Memory Leaks
--------------------------
COMMON MISTAKE: Creating temporary without freeing
BAD:
BigNum* result = add(createBigNum("5"), createBigNum("3"));
/* LEAK: The two createBigNum results are never freed! */

GOOD:
BigNum* five = createBigNum("5");
BigNum* three = createBigNum("3");
BigNum* result = add(five, three);
destroyBigNum(five);
destroyBigNum(three);
/* Later: destroyBigNum(result); */


================================================================================
7. ERROR HANDLING STRATEGY
================================================================================

7.1 Error Indication Method
----------------------------
DECISION: Return NULL for errors in functions returning BigNum*
RATIONALE:
- Natural C idiom
- Easy to check: if (result == NULL) { handle_error(); }
- Doesn't require additional error code parameter
- Consistent across all modules

EXAMPLE:
BigNum* divide(const BigNum* a, const BigNum* b) {
    if (isZero(b)) {
        return NULL;  /* Division by zero */
    }
    /* ... normal operation ... */
}

7.2 Error Messages (Must be EXACT per specification)
-----------------------------------------------------
REQUIREMENT: Exact text matching for error messages

MESSAGES:
1. "Invalid input file!\n" - File doesn't exist
2. "Invalid command!\n" - Unknown command
3. "Syntax error!\n" - Malformed expression
4. "Division by zero!\n" - Divide or modulo by zero
5. "Input of factorial must not be negative!\n" - Factorial of negative

IMPLEMENTATION NOTE:
Store in evaluator.c:
const char* ERROR_DIV_ZERO = "Division by zero!";
const char* ERROR_FACTORIAL_NEGATIVE = "Input of factorial must not be negative!";
etc.

7.3 Error Propagation
----------------------
PATTERN: Check for NULL and propagate up call stack

EXAMPLE:
BigNum* complexOperation(BigNum* a, BigNum* b) {
    BigNum* temp1 = multiply(a, b);
    if (temp1 == NULL) return NULL;  /* Propagate */

    BigNum* temp2 = add(temp1, a);
    destroyBigNum(temp1);
    if (temp2 == NULL) return NULL;  /* Propagate */

    return temp2;
}

7.4 Input Validation
--------------------
VALIDATION POINTS:
1. File existence (before opening)
2. Number format (during parsing)
3. Operator validity (during tokenization)
4. Balanced parentheses (during parsing)
5. Division by zero (before operation)
6. Negative factorial input (before operation)
7. Negative exponent (before operation)


================================================================================
8. CODE STYLE AND CONVENTIONS
================================================================================

8.1 Naming Convention: camelCase
---------------------------------
DECISION: Use camelCase for all identifiers
RATIONALE:
- Specified in project requirements
- Consistent throughout codebase
- Distinguishes our code from standard library (snake_case)

EXAMPLES:
Functions: createBigNum, destroyBigNum, isLess
Variables: currentBase, lenA, maxLen
Types: BigNum, Token, EvalResult
Constants: #define MAX_LINE_LENGTH (UPPER_CASE)

8.2 Code Organization
----------------------
HEADER FILES (.h):
- Doxygen documentation comments
- Function prototypes only
- Type definitions
- No executable code (avoid P207 error)

SOURCE FILES (.c):
- Implementation only
- Static helper functions (private)
- Detailed comments for complex algorithms

8.3 Comment Style
-----------------
DOXYGEN STYLE (headers):
/**
 * @brief Brief description
 * @param name Description
 * @return Description
 */

INLINE COMMENTS (source):
/* Explanation of algorithm step */
Single-line for quick notes

8.4 Error Handling Style
-------------------------
PATTERN: Early return on error
if (param == NULL) return NULL;
if (error_condition) {
    cleanup();
    return NULL;
}
/* Continue with normal operation */

8.5 ANSI C89 Compliance
------------------------
RESTRICTIONS:
- All variables declared at block start
- No C99/C11 features (no // comments, no inline, etc.)
- No VLAs (variable-length arrays)
- No declarations in for loop: for (int i = 0; ...)

REQUIRED STYLE:
void function(void) {
    int i;
    char* result;

    /* All declarations first */
    result = malloc(100);
    for (i = 0; i < 10; i++) {
        /* ... */
    }
}


================================================================================
9. TESTING STRATEGY
================================================================================

9.1 Unit Testing Approach
--------------------------
STRATEGY: Test each module independently before integration

TEST CASES PER MODULE:
bignum:
- Create from valid/invalid strings
- Copy and destroy
- Comparison operations with various number sizes

bignum_ops:
- Each operation with positive/negative combinations
- Zero cases
- Edge cases (large numbers)

bignum_math:
- Power with 0, 1, large exponents
- Factorial of 0, 1, small, large numbers
- Error cases (negative inputs)

converter/formatter:
- Each format with positive/negative numbers
- Two's complement edge cases
- Minimal representation verification

parser:
- Valid expressions
- Invalid syntax
- Operator precedence
- Parentheses nesting
- Unary operators

evaluator:
- Each operator
- Error handling
- Complex expressions

9.2 Integration Testing
------------------------
TESTS:
1. Simple expressions: "1 + 1", "5 * 3"
2. Complex expressions: "2 ^ 3 ^ 2", "(1 + 2) * 3"
3. Large numbers: "50!", "2 ^ 100"
4. Two's complement: "0b11 + 0x0f"
5. Error cases: "5 / 0", "(-5)!"
6. Format switching: dec/bin/hex commands

9.3 Test Cases from Specification
----------------------------------
MUST VERIFY (from PDF examples):
1. 1 + 0x000001 + 0b01 = 3
2. 0b11 = -1 (two's complement)
3. 0xb = -5 (two's complement)
4. 0xffffff...f = -1
5. Large factorial: 49!^9
6. Negative factorial error: 0xf1!


================================================================================
10. COMPARISON WITH REFERENCE IMPLEMENTATION
================================================================================

10.1 Major Differences
----------------------
OUR APPROACH vs REFERENCE:

1. Number Representation:
   - US: Decimal strings + sign flag
   - REF: Pseudo-hexadecimal encoding

2. Module Organization:
   - US: 8 focused modules
   - REF: 7 modules with combined functionality

3. Converter/Formatter:
   - US: Separated (converter.c + formatter.c)
   - REF: Combined (converter.c)

4. Expression Handling:
   - US: Separated (parser.c + evaluator.c)
   - REF: Combined (expression.c)

5. Number Types:
   - US: Single BigNum type
   - REF: Two types (big_int + big_dec)

10.2 Why Our Approach is Different
-----------------------------------
GOAL: Academic integrity - cannot copy reference
APPROACH: Study concepts, implement differently

KEY DISTINCTIONS:
- Different algorithms (same complexity class)
- Different data structures
- Different module breakdown
- Different function names
- Different implementation details

SHARED CONCEPTS (unavoidable):
- Must handle two's complement (spec requirement)
- Must use some parsing algorithm
- Must implement bignum arithmetic somehow
- Must follow spec requirements

10.3 Advantages of Our Approach
--------------------------------
SIMPLICITY:
- Easier to understand decimal representation
- Clearer module boundaries
- More focused files

MAINTAINABILITY:
- Better separation of concerns
- Easier to test individual components
- Clearer code organization

LEARNING:
- Better understanding through fresh implementation
- Deeper grasp of algorithms
- Own design decisions

10.4 Potential Optimizations (Future Work)
-------------------------------------------
IF PERFORMANCE BECOMES ISSUE:
1. Use higher base internally (base 10^9)
2. Implement Karatsuba multiplication
3. Use tree-based factorial for n > 10000
4. Cache commonly-used constants (0, 1, 2, 10)
5. Use memory pools for BigNum allocation

CURRENT APPROACH: Prioritize correctness and clarity over optimization


================================================================================
11. LESSONS LEARNED & DESIGN PRINCIPLES
================================================================================

11.1 Key Principles Applied
----------------------------
1. YAGNI (You Aren't Gonna Need It)
   - Don't over-optimize prematurely
   - Simple algorithms sufficient for project scope

2. KISS (Keep It Simple, Stupid)
   - Decimal strings simpler than pseudo-hex
   - Subtraction via negation simpler than direct algorithm

3. DRY (Don't Repeat Yourself)
   - Helper functions for common operations
   - Reuse arithmetic operations in math operations

4. Separation of Concerns
   - Each module has single responsibility
   - Clear interfaces between modules

5. Fail Fast
   - Check errors immediately
   - Return NULL on first error
   - Don't continue with invalid state

11.2 What Worked Well
----------------------
- Modular design made development smooth
- Starting with utils module provided solid foundation
- Writing tests as we go caught bugs early
- Documentation-first approach (headers before implementation)
- Memory management discipline from start

11.3 What Could Be Improved
----------------------------
- Could add more comprehensive test suite
- Division algorithm could be optimized
- Could add debug logging for easier troubleshooting
- Could implement operator overloading if using C++
- Could add performance benchmarking


================================================================================
12. FINAL RECOMMENDATIONS
================================================================================

For Future Development:
1. Add comprehensive unit tests
2. Add performance benchmarks
3. Consider optimization if needed
4. Add debug mode with logging
5. Consider REPL-style improvements for usability

For Documentation:
1. Use this analysis as basis for written report
2. Include algorithm complexity analysis
3. Explain two's complement handling clearly
4. Describe testing methodology
5. Include memory management discussion

For Code Review:
1. Verify no memory leaks with valgrind
2. Test edge cases thoroughly
3. Verify exact error messages
4. Test cross-platform compilation
5. Verify ANSI C89 compliance

================================================================================
END OF ANALYSIS DOCUMENT
================================================================================
